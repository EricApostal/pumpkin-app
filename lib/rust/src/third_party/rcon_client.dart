// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RCONClient>>
abstract class RconClient implements RustOpaqueInterface {
  /// Auth on game server
  /// RCON client
  Future<AuthResponse> auth({required AuthRequest auth});

  String get url;

  set url(String url);

  /// Execute request
  /// RCON client
  Future<RCONResponse> execute({required RCONRequest data});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create new connection
  /// RCON client
  static Future<RconClient> newInstance({required RCONConfig config}) =>
      RustLib.instance.api.rconClientRconClientNew(config: config);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RCONError>>
abstract class RconError implements RustOpaqueInterface {}

/// Request for auth in RCON
class AuthRequest {
  final BigInt id;
  final int requestType;
  final String password;

  const AuthRequest({
    required this.id,
    required this.requestType,
    required this.password,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create new auth request data
  static Future<AuthRequest> newInstance({required String password}) =>
      RustLib.instance.api.rconClientAuthRequestNew(password: password);

  @override
  int get hashCode => id.hashCode ^ requestType.hashCode ^ password.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AuthRequest &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          requestType == other.requestType &&
          password == other.password;
}

/// Response from auth request
class AuthResponse {
  final PlatformInt64 id;
  final int responseType;

  const AuthResponse({required this.id, required this.responseType});

  /// Is auth success
  Future<bool> isSuccess() =>
      RustLib.instance.api.rconClientAuthResponseIsSuccess(that: this);

  @override
  int get hashCode => id.hashCode ^ responseType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AuthResponse &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          responseType == other.responseType;
}

/// Configuration for RCON client
class RCONConfig {
  /// URL to server listening RCON
  /// example: `0.0.0.0:25575` or `donkey-engine.host:1337`
  final String url;

  /// Timeout in secs for commands sending to server
  /// Default: 30 secs
  final BigInt? writeTimeout;

  /// Timeout in secs for response waiting from server
  /// Default: 30 secs
  final BigInt? readTimeout;

  const RCONConfig({required this.url, this.writeTimeout, this.readTimeout});

  static Future<RCONConfig> default_() =>
      RustLib.instance.api.rconClientRconConfigDefault();

  @override
  int get hashCode =>
      url.hashCode ^ writeTimeout.hashCode ^ readTimeout.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RCONConfig &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          writeTimeout == other.writeTimeout &&
          readTimeout == other.readTimeout;
}

/// Request for RCON command
class RCONRequest {
  final BigInt id;
  final int requestType;
  final String body;

  const RCONRequest({
    required this.id,
    required this.requestType,
    required this.body,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<RCONRequest> newInstance({required String body}) =>
      RustLib.instance.api.rconClientRconRequestNew(body: body);

  @override
  int get hashCode => id.hashCode ^ requestType.hashCode ^ body.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RCONRequest &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          requestType == other.requestType &&
          body == other.body;
}

/// Response for RCON command
class RCONResponse {
  final PlatformInt64 id;
  final int responseType;
  final String body;

  const RCONResponse({
    required this.id,
    required this.responseType,
    required this.body,
  });

  @override
  int get hashCode => id.hashCode ^ responseType.hashCode ^ body.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RCONResponse &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          responseType == other.responseType &&
          body == other.body;
}
